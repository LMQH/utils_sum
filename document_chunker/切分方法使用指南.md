# 切分方法（chunk_method）使用指南

## 概述

本文档详细说明系统中所有可用的文本切分方法，包括方法名称、参数配置、适用场景和实现逻辑。通过选择合适的切分方法，可以优化文档的向量化效果和检索精度。（关于“chunk_method”支持的方法的说明）

## 切分方法列表

系统支持以下6种切分方法：

1. [固定大小分块](#1-固定大小分块-fixed_size)
2. [递归字符分块](#2-递归字符分块-recursive_character)
3. [语义分块](#3-语义分块-semantic)
4. [基于文档结构的分块](#4-基于文档结构的分块-structure)
5. [JSON行分块](#5-json行分块-json_line)
6. [父子分块](#6-父子分块-parent_child_split)

**注意**：`paragraph` 方法已移除，如需段落切分功能，请使用 `structure` 方法并配置 `paragraph_separator: '\n\n'`。

---

## 1. 固定大小分块（fixed_size）

### 方法信息

- **方法名称**：固定大小分块
- **chunk_method值**：`"fixed_size"`
- **代码实现**：`TextSpliter.fixed_size_split()`

### 参数设置

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `chunk_size` | int | 500 | 每个块的目标字符数 |
| `overlap` | int | 25 | 相邻块之间的重叠字符数 |

### 代码示例

```python
# API请求示例
{
    "chunk_method": "fixed_size",
    "chunk_size": 500,
    "overlap": 25
}
```

### 适用的文档类型

- ✅ **所有文本格式**：Markdown、TXT、Word、PDF等
- ✅ **无特定结构要求**：适合结构不清晰或格式混乱的文档

### 适合的内容形式

- 普通文本内容
- 无明确段落分隔的连续文本
- 对切分边界要求不高的场景

### 方法实现逻辑简介

1. 使用 `CharacterTextSplitter` 按字符数切分
2. 从文本开头开始，每 `chunk_size` 个字符创建一个块
3. 相邻块之间保留 `overlap` 个字符的重叠
4. 不考虑句子或段落边界，可能在句子中间切分

**优点**：
- 实现简单，切分速度快
- 块大小可控，便于管理
- 处理速度最快

**缺点**：
- 可能破坏句子或段落的完整性
- 可能在关键词中间切分，影响检索精度
- 不考虑语义边界

---

## 2. 递归字符分块（recursive_character）

### 方法信息

- **方法名称**：递归字符分块
- **chunk_method值**：`"recursive_character"`
- **代码实现**：`TextSpliter.recursive_character_split()`

### 参数设置

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `chunk_size` | int | 500 | 每个块的目标字符数 |
| `overlap` | int | 25 | 相邻块之间的重叠字符数 |
| `separators` | List[str] | `["\n\n", "\n", " ", ""]` | 分隔符列表，按优先级排序 |

### 代码示例

```python
# API请求示例
{
    "chunk_method": "recursive_character",
    "chunk_size": 500,
    "overlap": 25,
    "separators": ["\n\n", "\n", " ", ""]
}
```

### 适用的文档类型

- ✅ **所有文本格式**：Markdown、TXT、Word、PDF等
- ✅ **有段落结构的文档**：适合有明确段落分隔的文档

### 适合的内容形式

- 有段落分隔符（双换行符 `\n\n`）的文档
- 有行分隔符（单换行符 `\n`）的文档
- 普通文本（按空格分隔）

### 方法实现逻辑简介

1. 使用 `RecursiveCharacterTextSplitter` 按分隔符优先级递归切分
2. **优先级1**：尝试按 `\n\n`（段落分隔符）切分
3. **优先级2**：如果块仍太大，尝试按 `\n`（行分隔符）切分
4. **优先级3**：如果块仍太大，尝试按空格切分
5. **优先级4**：如果仍太大，按字符强制切分
6. 相邻块之间保留 `overlap` 个字符的重叠

**优点**：
- 优先在自然边界（段落、句子）处切分
- 比固定大小分块更智能，保持语义完整性
- 可自定义分隔符优先级
- 处理速度较快

**缺点**：
- 如果文档没有合适的分隔符，会退化为固定大小分块
- 块大小可能不完全一致

---

## 3. 语义分块（semantic）

### 方法信息

- **方法名称**：语义分块
- **chunk_method值**：`"semantic"`
- **代码实现**：`TextSpliter.semantic_split()`

### 参数设置

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `chunk_size` | int | 500 | 每个块的目标字符数（作为大小限制） |
| `overlap` | int | 25 | 此参数在此方法中不使用 |
| `embedding_model` | str | "bge-m3" | 用于计算语义相似度的嵌入模型 |
| `similarity_threshold` | float | 0.7 | 语义相似度阈值（代码中硬编码） |
| `embedding_dim` | int | 1024 | 嵌入向量维度（仅用于API模型） |

**注意**：
- 支持API模型（如 `text-embedding-v4`）和本地模型（如 `BAAI/bge-m3`）
- **优先使用API模型**：如果配置了API模型名且提供了 `api_key`，会优先尝试使用API模型
- **自动回退机制**：如果API调用失败，会自动回退到本地模型（API模型名会使用默认本地模型 `BAAI/bge-m3`）
- 如果使用API模型，超长句子（>8000字符）会自动分割处理

### 代码示例

```python
# API请求示例
{
    "chunk_method": "semantic",
    "chunk_size": 500,
    "overlap": 25,
    "embedding_model": "text-embedding-v4"  # 或 "BAAI/bge-m3"
}
```

### 适用的文档类型

- ✅ **所有文本格式**：Markdown、TXT、Word、PDF等
- ✅ **语义连贯的文档**：适合主题明确、语义相关的文档

### 适合的内容形式

- 有明确句子边界（句号 `.`）的文档
- 语义相关的段落
- 需要保持语义完整性的文档

### 方法实现逻辑简介

1. **句子分割**：将文本按句号 `.` 分割成句子列表
2. **句子编码**（优先级顺序）：
   - **优先尝试API模型**：
     - 如果配置了API模型名（如 `text-embedding-v4`）且提供了 `api_key`，优先尝试使用API模型
     - 使用 OpenAI 兼容API调用嵌入模型
     - 超长句子（>8000字符）会自动分割，然后加权平均合并嵌入向量
   - **自动回退到本地模型**：
     - 如果API调用失败（网络错误、API限制、认证失败等），自动回退到本地模型
     - 如果配置的是API模型名，使用默认本地模型 `BAAI/bge-m3`
     - 如果配置的是本地模型名，使用配置的模型
     - 使用 `SentenceTransformer` 加载本地模型
   - **备选模型**：如果本地模型加载失败，尝试使用备选模型 `BAAI/bge-m3`
3. **相似度计算**：计算相邻句子之间的余弦相似度
4. **分块判断**：
   - 如果相似度 < 0.7（语义发生变化），创建新块
   - 如果累积字符数 > `chunk_size`（达到大小限制），创建新块
5. **块构建**：将语义相似的句子组合成块

**优点**：
- 根据语义相似度切分，保持语义完整性
- 能够识别主题变化，在语义边界处切分
- **智能模型选择**：优先使用API模型（性能更好），失败时自动回退到本地模型
- **高可用性**：API失败不影响功能，自动容错
- 支持API模型和本地模型
- 自动处理超长句子

**缺点**：
- 计算开销大，需要调用嵌入模型
- 处理速度较慢（API模型受网络影响，本地模型受硬件影响）
- 依赖句子边界（句号），对无标点文本效果不佳
- API调用可能产生费用
- API调用失败时会有额外的回退时间开销

---

## 4. 基于文档结构的分块（structure）

### 方法信息

- **方法名称**：基于文档结构的分块
- **chunk_method值**：`"structure"`
- **代码实现**：`TextSpliter.structure_split()`

### 参数设置

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `structure_markers` | Dict[str, any] | `{}` | 结构标记字典，支持多种分隔符模式 |

**重要说明**：
- `structure_markers` 支持以下配置模式（按优先级顺序）：
  1. **`line_separator`**：按行切分，每行作为一个块（适合每行一条记录的文档）
  2. **`paragraph_separator`**：按段落切分（如双换行符 `\n\n`）
  3. **`custom_separator`**：自定义字符串分隔符
  4. **`title`**：按标题标记切分（默认，向后兼容）
- 如果 `structure_markers` 未配置或为空，会使用默认的Markdown标题标记：`["# ", "## ", "### ", "#### ", "##### ", "###### "]`
- `structure_markers['title']` 不能为空列表，否则会抛出错误

### 代码示例

```python
# API请求示例 - 使用默认Markdown标题（推荐）
{
    "chunk_method": "structure"
    # structure_markers 可以不传，会使用默认值
}

# API请求示例 - 自定义标题标记
{
    "chunk_method": "structure",
    "structure_markers": {
        "title": ["# ", "## ", "### ", "#### ", "##### ", "###### "]
    }
}

# API请求示例 - 按行切分（适合项目基础信息.md这类文件）
{
    "chunk_method": "structure",
    "structure_markers": {
        "line_separator": true  # 或任意非空值
    }
}

# API请求示例 - 按段落切分（双换行符）
{
    "chunk_method": "structure",
    "structure_markers": {
        "paragraph_separator": "\n\n"
    }
}

# API请求示例 - 自定义分隔符（保留分隔符在块开头）
{
    "chunk_method": "structure",
    "structure_markers": {
        "custom_separator": "---"  # 使用 "---" 作为分隔符，分隔符会保留在每个块的开头
    }
}

# API请求示例 - 使用转义字符
{
    "chunk_method": "structure",
    "structure_markers": {
        "paragraph_separator": "\\n\\n"  # 会被解析为实际的换行符
    }
}

# API请求示例 - 其他格式文档（自定义标题标记）
{
    "chunk_method": "structure",
    "structure_markers": {
        "title": ["第", "章", "第", "节"]  # 自定义标题标记
    }
}
```

### 适用的文档类型

- ✅ **Markdown文档**（.md）：最常用，支持标题标记
- ✅ **Word文档**（.docx/.doc）：转换为Markdown后使用
- ✅ **PDF文档**（.pdf）：转换为Markdown后使用
- ✅ **结构化文档**：有明确标题结构的文档
- ✅ **每行一条记录的文档**：使用 `line_separator` 模式
- ✅ **段落结构清晰的文档**：使用 `paragraph_separator` 模式

### 适合的内容形式

- **标题模式**（默认）：
  - 有标题标记的文档（如 Markdown 的 `#`、`##` 等）
  - 每个标题下有相关内容的文档
  - 需要保持文档层次结构的场景
- **行分隔模式**（`line_separator`）：
  - 每行一条独立记录的文档
  - 没有标题标记但需要按行切分的文档
  - 如：项目列表、数据记录等
- **段落分隔模式**（`paragraph_separator`）：
  - 有明确段落分隔符的文档
  - 段落结构清晰的文档
- **自定义分隔模式**（`custom_separator`）：
  - 有特定分隔符的文档
  - 需要自定义切分规则的场景
  - 需要保留分隔符信息的场景（分隔符会保留在每个块开头）

### 方法实现逻辑简介

方法支持多种分隔符模式，按以下优先级顺序检查配置：

1. **行分隔模式**（`line_separator`）：
   - 如果配置了 `line_separator`，按行切分
   - 每行作为一个独立的块
   - 自动过滤空行

2. **段落分隔模式**（`paragraph_separator`）：
   - 如果配置了 `paragraph_separator`，使用指定分隔符切分
   - 支持转义字符（如 `\n`、`\t` 等）
   - 每个分隔符之间的内容作为一个块
   - **注意**：分隔符不会保留在块中（与 `custom_separator` 不同）

3. **自定义分隔模式**（`custom_separator`）：
   - 如果配置了 `custom_separator`，使用指定字符串作为分隔符
   - 支持转义字符（如 `\n`、`\t` 等）
   - 每个分隔符之间的内容作为一个块
   - **重要特性**：分隔符会保留在每个块的开头（第一个块除外，除非文本以分隔符开头）
   - 例如：文本 `"chunk1---chunk2---chunk3"` 使用 `"---"` 分隔符，切分结果为：
     - `"chunk1"`
     - `"---chunk2"`
     - `"---chunk3"`

4. **标题模式**（默认，向后兼容）：
   - 如果未配置上述模式，使用标题切分
   - 如果未配置 `structure_markers`，使用默认Markdown标题标记
   - 使用正则表达式匹配标题行
   - 允许标题前有空白字符，标题标记后可以有空白字符
   - 遇到标题行：保存当前块，开始新块（包含标题）
   - 遇到非标题行：添加到当前块

**优点**：
- 支持多种切分模式，灵活适应不同文档格式
- 保持文档的层次结构（标题模式）
- 每个块都有明确的主题（标题模式）
- 适合技术文档、API文档等结构化文档
- 支持默认配置，使用方便
- 可以处理每行一条记录的文档（行分隔模式）
- 可以处理段落结构清晰的文档（段落分隔模式）

**缺点**：
- 标题模式下，块大小不可控，每个标题下的内容长度可能差异很大
- 标题模式下，对于没有明确结构的文档效果不佳
- 标题模式下，如果文档没有标题标记，所有内容会被当作一个块
- 行分隔模式下，如果单行内容很长，块会很大

**使用建议**：
- **Markdown文档（有标题）**：不配置或使用 `title` 模式
- **每行一条记录**：使用 `line_separator` 模式
- **段落结构清晰**：使用 `paragraph_separator` 模式
- **特殊格式**：使用 `custom_separator` 模式

---

## 5. JSON行分块（json_line）

### 方法信息

- **方法名称**：JSON行分块
- **chunk_method值**：`"json_line"`
- **代码实现**：`TextSpliter.json_line_split()`

### 参数设置

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| 无特殊参数 | - | - | 此方法不使用 `chunk_size` 和 `overlap` 参数 |

### 代码示例

```python
# API请求示例
{
    "chunk_method": "json_line",
    "chunk_size": 500,  # 此参数在此方法中不使用
    "overlap": 25       # 此参数在此方法中不使用
}
```

### 适用的文档类型

- ✅ **JSONL文件**（.jsonl）：每行一个JSON对象
- ✅ **JSON文件**（.json）：如果格式为每行一个JSON对象

### 适合的内容形式

- 每行一个独立的JSON对象
- JSON Lines格式（JSONL）
- 结构化数据文件

### 方法实现逻辑简介

1. **按行分割**：将文本按换行符 `\n` 分割成行
2. **过滤空行**：去除空行和只包含空白字符的行
3. **块构建**：每行作为一个独立的块

**优点**：
- 实现简单，处理速度最快
- 每行独立，便于处理结构化数据
- 适合批量处理JSON数据

**缺点**：
- 只适用于JSONL格式
- 不考虑JSON内容的语义关系
- 如果JSON对象很大，单个块可能很大

---

## 6. 父子分块（parent_child_split）

### 方法信息

- **方法名称**：父子分块
- **chunk_method值**：`"parent_child_split"`
- **代码实现**：`ParentChildSpliter` 类（独立实现，不在 `TextSpliter` 中）

### 参数设置

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `chunk_size` | int | 500 | 父块的目标字符数（对应 `parent_size`） |
| `child_size` | int | 100 | 子块的目标字符数 |
| `overlap` | int | 25 | 子块之间的重叠字符数（对应 `child_overlap_size`） |

**重要约束**：
- `child_overlap_size` 必须小于 `child_size`，否则会自动调整为 `child_size / 4`
- 只支持 Markdown 格式文件（.md），其他格式需要先转换为 Markdown
- 文件扩展名必须为 `.md`，否则会抛出错误

### 代码示例

```python
# API请求示例
{
    "chunk_method": "parent_child_split",
    "chunk_size": 500,    # 父块大小
    "child_size": 100,    # 子块大小
    "overlap": 15         # 子块重叠大小
}
```

### 适用的文档类型

- ✅ **Markdown文档**（.md）：必需，其他格式不支持
- ✅ **Word文档**（.docx/.doc）：会自动转换为 Markdown 后使用
- ✅ **PDF文档**（.pdf）：会自动转换为 Markdown 后使用

### 适合的内容形式

- Markdown 格式的文档
- 有标题结构的文档（`#`、`##` 等）
- 包含图片、表格等复杂内容的文档
- 需要高检索精度的场景

### 方法实现逻辑简介

#### 父块划分逻辑

1. **标题处理**：
   - 识别 Markdown 标题（以 `#` 开头）
   - 维护标题栈，记录当前块的父标题
   - 遇到新标题时，保存当前块并开始新块

2. **图片处理**：
   - 识别 `![图片]` 标记
   - 将图片及其描述、内部表格作为一个整体处理
   - 图片块结束后合并到主块

3. **表格处理**：
   - 识别以 `|` 开头的表格行
   - 将表格与后续总结语句一起作为一个块

4. **普通文本**：
   - 按 `parent_size` 阈值切分
   - 超过阈值时保存当前块并开始新块

5. **上下文注入**：
   - 每个块自动添加父标题作为上下文信息

#### 子块划分逻辑

1. **小父块处理**：如果父块长度 < `child_size`，直接作为子块
2. **大父块处理**：
   - 按 `child_size` 大小切分
   - 相邻子块之间保留 `child_overlap_size` 的重叠
   - 所有子块标记为属于同一个父块（通过 `index` 字段关联）

#### 数据结构

每个块（父块和子块）包含以下字段：
```python
{
    "file_name": str,      # 文件名
    "pc_type": str,        # 块类型："parent" 或 "child"
    "index": int,          # 父块索引（用于关联父子块，父块为-1，子块为父块索引）
    "content": str         # 块内容
}
```

**优点**：
- 检索精度高：通过子块精确匹配，提高检索准确度
- 上下文完整：返回父块作为上下文，提供完整信息
- 语义感知：父块划分考虑文档结构，保持语义完整性
- 结构保持：能够识别和处理图片、表格等特殊内容
- 上下文注入：自动添加父标题作为上下文信息

**缺点**：
- 格式限制：只支持 Markdown 格式
- 存储空间大：需要存储父块和子块，占用更多存储空间
- 复杂度高：实现逻辑复杂，需要处理多种内容类型
- 处理速度较慢：两级分块需要更多处理时间

**适用场景**：
- Markdown 格式的技术文档
- 需要高检索精度的场景
- 包含图片、表格等复杂内容的文档
- 需要完整上下文的检索场景

---

## 切分方法选择建议

### 按文档类型选择

| 文档类型 | 推荐方法 | 备选方法 |
|---------|---------|---------|
| Markdown（有标题） | `parent_child_split` 或 `structure` | `recursive_character` |
| Markdown（无标题） | `recursive_character` | `fixed_size` |
| Word/PDF | `structure`（转换为MD后）或 `parent_child_split` | `recursive_character` |
| JSONL | `json_line` | - |
| 普通文本（有段落） | `structure`（`paragraph_separator`）或 `recursive_character` | `fixed_size` |
| 普通文本（无段落） | `recursive_character` | `fixed_size` |
| 每行一条记录（如项目列表） | `structure`（`line_separator`） | `json_line` |

### 按需求选择

| 需求 | 推荐方法 |
|------|---------|
| 检索精度要求高 | `parent_child_split` |
| 需要保持语义完整性 | `semantic` 或 `parent_child_split` |
| 需要保持文档结构 | `structure` 或 `parent_child_split` |
| 处理速度快 | `fixed_size`、`structure`（`line_separator`/`paragraph_separator`）或 `json_line` |
| 块大小可控 | `fixed_size` 或 `recursive_character` |
| 处理结构化数据 | `json_line` |
| 需要API模型支持 | `semantic`（使用 `text-embedding-v4`，失败时自动回退到本地模型） |

### 参数配置建议

#### 通用参数

- **chunk_size**：
  - 小文档（< 1000字）：200-300
  - 中等文档（1000-5000字）：500-800
  - 大文档（> 5000字）：800-1200

- **overlap**：
  - 通常设置为 `chunk_size` 的 5%-10%
  - 建议范围：25-100

#### 特殊参数

- **separators**（recursive_character）：
  - 默认：`["\n\n", "\n", " ", ""]`
  - 可根据文档格式调整优先级

- **structure_markers**（structure）：
  - **标题模式**：可以不配置，会使用默认Markdown标题标记；自定义格式：根据实际标题标记配置
  - **行分隔模式**：配置 `{"line_separator": true}`，适合每行一条记录的文档
  - **段落分隔模式**：配置 `{"paragraph_separator": "\n\n"}`，适合段落结构清晰的文档
  - **自定义分隔模式**：配置 `{"custom_separator": "分隔符"}`，支持转义字符（如 `\n`、`\t` 等）
    - **重要特性**：分隔符会保留在每个块的开头（第一个块除外，除非文本以分隔符开头）
    - 例如：`{"custom_separator": "---"}` 会将 `"chunk1---chunk2---chunk3"` 切分为 `["chunk1", "---chunk2", "---chunk3"]`

- **embedding_model**（semantic）：
  - API模型：`text-embedding-v4`、`text-embedding-v3` 等
  - 本地模型：`BAAI/bge-m3`、`all-MiniLM-L6-v2` 等

---

## 常见问题

### Q1: 为什么 `structure` 方法只返回一个块？

**A**: 
- **标题模式**：检查文档中是否有匹配的标题标记。如果文档中没有匹配的标题标记，所有内容会被当作一个块。建议使用默认的Markdown标题标记配置。
- **行分隔模式**：如果使用 `line_separator` 模式，确保文档每行都有内容，空行会被自动过滤。
- **段落分隔模式**：如果使用 `paragraph_separator` 模式，确保文档中有对应的分隔符（如 `\n\n`），否则整个文档会成为一个块。

### Q2: `parent_child_split` 方法报错"必须为Markdown文件"？

**A**: 该方法只支持 `.md` 文件。Word 和 PDF 文件需要先转换为 Markdown 格式（系统会自动转换）。确保文件扩展名为 `.md`。

### Q3: `semantic` 方法处理速度很慢？

**A**: 语义分块需要调用嵌入模型，计算开销大。如果对速度要求高，建议使用 `recursive_character` 或 `fixed_size`。如果使用API模型，还需要考虑网络延迟。

### Q4: 如何选择合适的 `chunk_size`？

**A**: 
- 考虑向量模型的上下文窗口限制
- 考虑检索精度需求（小块精度高，大块上下文完整）
- 建议从 500 开始，根据实际效果调整

### Q5: `semantic` 方法支持哪些模型？

**A**: 
- **API模型**：`text-embedding-v4`、`text-embedding-v3`、`text-embedding-v2` 等（需要提供 `api_key`）
- **本地模型**：任何 HuggingFace 上的 SentenceTransformer 模型，如 `BAAI/bge-m3`、`all-MiniLM-L6-v2` 等
- **模型选择策略**：如果配置了API模型名且提供了 `api_key`，会优先使用API模型；API调用失败时自动回退到本地模型

### Q6: `semantic` 方法遇到超长句子怎么办？

**A**: 系统会自动处理超长句子（>8000字符）：
- 自动在合适的分隔符处分割
- 对每个部分分别调用API（如果使用API模型）
- 使用加权平均合并嵌入向量

### Q7: `semantic` 方法API调用失败会怎样？

**A**: 系统具有自动容错机制：
- 如果API调用失败（网络错误、API限制、认证失败等），会自动回退到本地模型
- 如果配置的是API模型名，会使用默认本地模型 `BAAI/bge-m3`
- 如果本地模型也加载失败，会尝试备选模型 `BAAI/bge-m3`
- 所有回退过程都会记录日志，便于排查问题

---

## 总结

选择合适的切分方法需要考虑：
1. **文档类型**：Markdown、Word、PDF、JSONL等
2. **文档结构**：是否有标题、段落、列表等
3. **检索需求**：精度要求、上下文需求
4. **性能要求**：处理速度、计算资源
5. **模型支持**：是否需要API模型或本地模型

建议：
- **Markdown文档（有标题）**：优先使用 `parent_child_split` 或 `structure`（标题模式）
- **Markdown文档（无标题，每行一条记录）**：使用 `structure`（`line_separator` 模式）
- **普通文本（有段落）**：使用 `structure`（`paragraph_separator` 模式）或 `recursive_character`
- **普通文本（无段落）**：使用 `recursive_character`
- **结构化数据**：使用 `json_line`
- **快速处理**：使用 `fixed_size` 或 `structure`（`line_separator`/`paragraph_separator` 模式）
- **语义分块**：使用 `semantic`（支持API和本地模型）

通过合理选择和配置切分方法，可以显著提升知识库的检索效果。
